## 环境配置

### pipenv

为此项目创建单独的虚拟环境，cmd进入文件目录后，使用命令`pipenv install`

（如果之前已经在本地其他位置通过命令`pipenv install`安装了一个虚拟环境，那么现在在一个新项目的文件目录下使用`pipenv install`不会有任何问题。每个项目都可以拥有自己的虚拟环境，它们之间是独立的，不会相互影响。这样，您可以为每个项目安装不同版本的依赖项，而不必担心它们之间的冲突。）



预期结果：

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230831181310880.png" alt="image-20230831181310880" style="zoom:50%;" />



![image-20230831181149980](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230831181149980.png)







## 正文

### 重定向

重定向原理：在正常的访问流程中，当浏览器访问URL 1所指向的资源时，

正常的过程：服务器在接收后就把URL 1所指向的资源或者是页面，返回到浏览器这里来，并且状态码会设置成200

重定向：当访问URL 1这个地址时，务器在接收到这个这次请求之后，出于某种原因，

比如可能没有URL 1所对应的页面，也有可能是用户无权访问URL1所对应的这个页面，那么此时服务器会在它的返回的response的headers，也就是它的头里面增加一个标志位location，并且给这个location一个值URL，同时它会把返回的状态码更改成301或者是302，那么当浏览器，接收到了这个返回了之后，它首先会去看这个状态码，如果状态码是301或者是302，则知道服务器是要让它做一次重定向好，然后它就会再一次发送一个请求，那么这次请求的地址就是这个location里所设置的url2



### 视图函数的return和普通函数的return区别

​	视图函数中的`return`除了返回本身的内容之外，还会返回一些附加内容。例如，Flask框架会对视图函数的返回值进行封装，不仅仅返回一个字符串，还会返回一些状态码（status code），比如200、404、301等。此外，视图函数的返回值可以是多种类型，包括字符串、字典、元组等。例如，当返回值为字符串时，Flask会自动将其封装成response对象；当返回值为字典时，Flask会将其转换为JSON格式。总之，视图函数的`return`与普通函数的`return`在Flask框架中有所不同，具有更多的功能和灵活性。





比如在下面这个例子中，上面的视图函数返回了本身的内容外，还返回了状态码（status code）和非常重要的属性content-type，content-type放置于http的header里，content-type用于告诉http请求的接收方（用浏览器访问的，那么接收方就是浏览器）如何解析要返回的主体内容

content-type的默认值为：`content-type=text/html`，就是把文本内容当做html来解析

从本质上来讲，当在视图函数里面返回了一个很简单的字符串时，flask在背后会把这个字符串当做响应的主体内容，主体内容和刚刚谈到的一系列附加信息就会被封装成一个对象——response对象所以说，视图函数本质上永远返回的都是response对象

![image-20230904123838840](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230904123838840.png)

<iframe class="frame" src="https://www.bing.com/search?showonlyads=1&amp;codex_conid=51D%7CBingProd%7C2C9C595BBEAFFBFBADCDA078A45E3915F85158CDE7B4BE823A59F743DD85E28A&amp;codex_summ=%5B%7B%22author%22%3A%22bot%22%2C%22text%22%3A%22Generating+answers+for+you...%22%7D%2C%7B%22author%22%3A%22bot%22%2C%22text%22%3A%22Searching+the+web+for%3A+%60xampp+installation%60%22%7D%2C%7B%22author%22%3A%22user%22%2C%22text%22%3A%22xampp%E5%AE%89%E8%A3%85%22%7D%5D&amp;IG=E751F0F5072B41EA8B40C3A862D5AB7A&amp;IID=SERP.5028&amp;cw=1589&amp;ch=789&amp;form=codexx&amp;dissrchswrite=1&amp;kseed=7500&amp;SFX=2&amp;q=flask%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E7%9A%84return%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84return%E5%8C%BA%E5%88%AB&amp;iframeid=020b1bc5-e453-77f1-941e-104a7cc8562a&amp;cdxpc=SERP&amp;codex_src=sq" style="width: 0px; height: 0px;"></iframe>

### 路由



```py
@app.route('/hello/')# hello/后面的这个斜杠是为了兼容在url中，无论输入hello还是hello/都能调用函数hello_world
def hello_world():
    return 'Hello World!'

# app.add_url_rule('hello',view_func=hello_world)# 另一种注册路由方式

app.config.from_object('config')# 导入模块路径,使用此方法需要保证该模块中变量名全部大写，不然会被忽略掉
```

app语句写法

```py
app.run(debug=DEBUG)# 此时只能通过本机的ip地址访问，且是通过文件包导入方式读取配置文件config中的信息
app.run(debug=app.config['DEBUG'])#

app.run(host='0.0.0.0',debug=True)# 任意ip都可访问
```





### 客户端是如何通过URL地址最终访问到一个视图函数



客户端比如有浏览器或postman，视图函数如在本项目中的search，





我们可以用一个字典来保存URL和这个URL所对应的这个视图函数。那么这个字典里面的key就是URL，而字典的key所对应的值就是这个视图函数。

但是flask中，关于url和它视图函数的键值对应关系中间还有一层`endpoint`，用于反向构建URL

![image-20230905182100927](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905182100927.png)

​	如果只考虑一个URL正向的去寻找它所对应的视图函数的话，endpoint确实是多余，因为已经知道了URL，就可以通过这个URL的key找到对应的value值，从而访问我们设计的视图函数，但是如果考虑到反向构建这个URL时，endpoint就有用了。

​	在上面有关路由的笔记中，有下面的一句

```py
app.add_url_rule('hello',view_func=hello_world)# 另一种注册路由方式
```

其实，在路由中也可以自己对`endpoint`赋值，但系统会默认赋值为视图函数

![image-20230905182529953](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905182529953.png)



### route装饰器内部工作原理

由于使用pycharm的调试工具时，不会在route装饰器内断点运行，因此选中route后右键跳转其实现

![image-20230905185946890](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905185946890.png)

route函数实质是调用`add_url_rule`函数

![image-20230905185746110](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905185746110.png)

在route的内部函数中，首先它会把这个rule——我们编写的URL规则（也就是`/book/search/<q>/<page>`）传到`add_url_rule`方法里面去，接着它会传参数endpoint，然后是传参数——真正视图函数f。好，然后呢？我们再看一下啊AD dur入的内部啊。



#### `add_url_rule`函数内部

如果endpoint为空，就会取view_func的名称作为endpoint的名称，

![image-20230905190616877](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905190616877.png)

最终会把我们编写的规则放到url_map里，

然后是非常关键的一个地方：规则是存储在url_map里面的，然后我们的视图函数是存在view_functions的字典里

![image-20230905191101285](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905191101285.png)

还有这里的self，其实就是指flask的核心对象，也就是在启动文件里实例化的app，这就是：

```py
app = Flask(__name__)
```



​	因此如果路由要注册成功，那么它必须在url_map这个map对象中和这个view_functions的字典里分别要存储一个URL 的endpoint和view_func的

​	如果没有的话，那么这个路由就肯定没有注册成功好



### LocalProxy

![image-20230908124618186](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908124618186.png)



### 上下文

​	本质上都是对象

查看第三方包源码方法

![image-20230908125315163](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908125315163.png)

而关于flask的上下文有关源码：在site-packages文件夹下：

![image-20230908125428197](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908125428197.png)

最后这两项就分别是应用上下文和请求上下文

![image-20230908125514960](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908125514960.png)

#### 应用上下文

​	提供对核心对象Flask对象的封装，并在封装之上提供了一系列方法

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908130458168.png" alt="image-20230908130458168" style="zoom:67%;" />

#### 请求上下文

​	提供对请求Request对象的封装，并在封装之上提供了一系列方法

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908130559163.png" alt="image-20230908130559163" style="zoom:50%;" />

​	因此就涉及到了Flask 、AppContext、 Request、 RequestContext这四个类的对象， flask的核心对象它其实也是是被存储在AppContext中的，而请求对象Request通常是被存储在RequestContext中。

​	这就涉及到设计思想了，回到上下文里来，为什么会需要一个上下文？为什么不能直接操作Flask 核心对象？其实有时候对于一个对象来说，有一些信息是属于这个对象外部的，并不是属于这个对象本身的，那么我们其实是可以设计一个所谓的上下文，上下文对象它主要是封装flask核心对象的+除了此核心对象之外还需要外部的一些参数或是数据，因此就把外部的参数数据和flask核心对象一起组成一个新的对象，这就是上下文。同时还可以在上下文的对象上面再提供一系列的方法，从而构成了一个新的对象。



**这四个对象的作用和意义：**

`Flask`对象是核心对象，核心对象里面承载着各种各样的功能，比如说保存了配置文件的信息，提供了注册路由、视图函数等等这样的一系列的功能。

`AppContext`是把这个核心对象做了一个封装，并且附加了一些额外的参数。

`Request`是保存了请求信息，比如相关URL的参数、完整的URL等一切的请求信息都在request对象中

`RequestContext`同样是对这个request对象的一个封装。



​	编码时往往真正想去使用的是Flask的核心对象或Request请求的对象，但要使用它并不意味着一定要直接去from——从某一个地方导入，而是应该从上下文context中拿Flask的核心对象或request请求对象。

​	既然要通过上下文来获取Flask和Request，那么是不是要从某一个地方来from导入相关的context？但其实是从来没有直接去操作这个上下文，这是为什么呢？其实这就是`LocalProxy`代理的作用，Flask和Request的上下文分别是current_app、request，这两个LocalProxy提供了间接去操作这个上下文的能力，换句话来说，current_app、request其实都是指向的是Flask的核心对象和Request的请求类，只不过用了一种设计模式里面的代理模式。

![image-20230908132618786](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908132618786.png)



### flask工作原理



![image-20230908171909659](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908171909659.png)





​	Flask主要是用来编写web应用，因此探讨flask是如何操作应用上下文和请求上下文时，必须从一个请求进入flask框架开始探讨。

当一个请求进入到我们flask框架之后，flask首先会实例化一个`RequestContext`（请求上下文），而请求上下文封装了这一次请求的相关信息，放在Request里，那么Flask在生成了请求上下文后，会把请求上下文推入到一个栈（先进后出）结构——`LocalStack`中`LocalStack`是一个类，它需要实例化（为其对象分配存储空间），它实例化了后用`_request_ctx_stack`变量表示。

​	另外一个上下文对象同样是由类	`LocalStack`实例化，存储到变量`_app_ctx_stack`里,

![image-20230908173256459](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230908173256459.png)



​	**`RequestContext`在入站之前,flask首先会检查另外的`_app_ctx_stack`栈的栈顶元素，如果栈顶元素为空或不是当前的app对象，那么Flask首先会把包含核心对象app的AppContext给推入到`_app_ctx_stack`栈中，然后才会把`RequestContext`推到`_request_ctx_stack`中**

​	接着讨论request和current_app的实现原理：这两个变量如图中所画的，永远都是指向对应的栈顶元素，因此，当使用app或是request时，它们的`Local Proxy`就在间接的操作对应两个栈的栈顶元素，而这两个栈的栈顶元素分别是两个上下文。

因此，只有当这两个栈的栈顶元素都是空的，`Local Proxy`就会显示unBound标识

而且，**在一个请求中使用current_app.config[]也不用先将应用上下文引入栈中**

这就涉及到如何将一个上下文推入到对应的栈中，如图即实现了（入栈后别忘记了出栈）

![image-20230910170646102](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910170646102.png)

或者

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910175443595.png" alt="image-20230910175443595" style="zoom:67%;" />





#### current_app

注意上图中，current_app虽然指向栈顶元素（应用上下文），但是上面代码中a=current_app中返回的是核心对象app

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910164748511.png" alt="image-20230910164748511" style="zoom:67%;" />

current_app也是实例化的`LocalProxy`

```py
current_app = LocalProxy(_find_app)
```

![image-20230910165016400](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910165016400.png)

_find_app函数

源码：取app对应的栈顶元素为top（应用上下文），但是该函数并没有把整个应用上下文返回，而是返回它的app属性——top.app，也就是核心对象所在部分

```py
def _find_app():
    top = _app_ctx_stack.top
    if top is None:
        raise RuntimeError(_app_ctx_err_msg)
    return top.app
```

#### request

同理，也是存的Request请求对象

```py
request = LocalProxy(partial(_lookup_req_object,'request'))
```

`_lookup_req_object`函数定义

```py
def _lookup_req_object(name):
    top = _request_ctx_stack.top 
    if top is None: 
        raise RuntimeError(_request_ctx_err_msg)
    return getattr(top, name)
```

它同样取 _request_ctx_stack的栈顶元素，但最终也不是直接返回栈顶元素，而是用的getattr方法去获取了top的一个属性，而参数name传的值为request，也就是寻找request属性啊。好，然后呢？我们回到我们的这个text代码这里来啊。那么我刚刚演示的啊，这样的是一种入账的方法。这样的入站的方法呢？稍微的有一些啊，不够简洁，那么我们把这个入站的方法呢给改一下。



### with语句

`with` 语句的工作原理基于上下文管理协议，这个协议要求一个对象实现 `__enter__` 和 `__exit__` 方法。

1. `__enter__` 方法：

   - 当执行进入 `with` 语句块时，`__enter__` 方法会被调用。
   - 它负责返回一个被用于在 `with` 语句块中使用的对象。通常，它会返回一个资源（如文件对象、数据库连接等）。
   - 这个返回值会被赋给 `as` 后的变量。

2. `__exit__` 方法：

   - 无论 `with` 语句块内发生什么，`__exit__` 方法都会被调用。
   - 它接收三个参数：`exc_type`、`exc_value` 和 `traceback`，用于处理可能发生的异常情况。
   - 如果在 `with` 语句块内没有发生异常，这三个参数都为 `None`。
   - 如果在 `with` 语句块内发生了异常，这三个参数将包含有关异常的信息。

   - 如果 `__exit__` 方法返回 `True`，那么异常将被清理（即不会被抛出）。
   - 如果返回 `False` 或者什么都不返回，异常将被 `with` 语句块捕获并继续传播。

下面是一个简单的例子：

```python
class CustomResource:
    def __enter__(self):
        print('Entering context...')
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            print(f'An error of type {exc_type} occurred with message: {exc_value}')
        print('Exiting context...')

# 使用with语句
with CustomResource() as resource:
    print('Doing some work...')
    # 在这里可以使用resource代表的资源

# 在这里退出了with语句块，资源会被自动清理
```

在这个例子中，`CustomResource` 类实现了上下文管理协议。当 `with` 语句开始执行时，`__enter__` 方法会被调用，它返回了一个 `CustomResource` 对象，该对象被赋给 `resource` 变量。然后 `with` 语句块中的代码会执行。

无论在 `with` 语句块中是否发生了异常，都会在退出 `with` 语句块时调用 `__exit__` 方法。如果发生了异常，`exc_type`、`exc_value` 和 `traceback` 将包含异常的相关信息。

总的来说，`__enter__` 和 `__exit__` 方法使得你可以在进入和退出上下文时执行特定的操作，从而实现了资源的自动管理。

#### 用with语句引入应用上下文

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910175443595.png" alt="image-20230910175443595" style="zoom:67%;" />

app_tontext()函数实现：主要是返回AppContext()函数返回值

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910180329464.png" alt="image-20230910180329464" style="zoom:50%;" />

而AppContext()函数内部：

![image-20230910180234966](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910180234966.png)



#### 上下文管理器



with语句举例：

![image-20230910181015606](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910181015606.png)

这里的obj_A并不是上下文管理器，而是A类的`__enter__`方法的返回值

![image-20230910181209124](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230910181209124.png)

其实上面写的`__exit__`函数其实有问题，应该有4个参数

`__exit__`函数主要是回收资源和处理异常，最后这三个参数于异常处理有关，如果没有异常，那么它们都为空

```py
def _exit__(self, exc_type, exc_value, tb)
```

当执行到有异常的语句时，就会自动调用`__exit__`函数，并且`__exit__`函数只能返回True或者False（默认为False），如果为False，with语句外部也会抛出异常



### 进程和线程

进程（Process）和线程（Thread）是计算机中两个基本的执行单元，它们用于执行程序的代码。

#### 进程（Process）：

1. **定义**：
   - 进程是操作系统中的一个程序执行实例。一个程序可以包含多个进程，每个进程都有自己独立的内存空间和系统资源。
   - 每个进程都有自己的代码段、数据段、堆栈等。

2. **特点**：
   - 进程之间相互独立，一个进程的崩溃不会影响其他进程的执行。
   - 进程之间需要通过进程间通信（Inter-Process Communication, IPC）来进行数据传递。

3. **资源**：
   - 每个进程有自己独立的内存空间和系统资源，它们不会共享。

4. **开销**：
   - 创建和撤销进程的开销相对较大，因为每个进程都需要分配独立的内存空间。

5. **并行执行**：
   - 进程可以并行执行在多核处理器上，每个进程都在独立的处理器核心上运行。

#### 线程（Thread）：

1. **定义**：
   - 线程是一个进程内部的执行单元。一个进程可以包含多个线程，它们共享进程的内存空间和系统资源。

2. **特点**：
   - 线程之间共享进程的内存空间，可以直接访问相同的数据。

3. **资源**：
   - 线程之间共享相同的内存空间和系统资源。

4. **开销**：
   - 创建和撤销线程的开销相对较小，因为它们共享相同的内存空间。

5. **并发执行**：
   - 线程在同一个进程内并发执行。在单核处理器上，线程是通过时间片轮转实现的，使得多个线程看起来在同时执行。

6. **同步**：
   - 因为线程共享相同的内存空间，需要谨慎处理共享数据的同步问题，以避免出现竞态条件等问题。

进程和线程都是用于执行代码的执行单元，但它们有不同的特点和适用场景。

#### 区别

1.进程更适用于分配资源（如内存资源）、并行执行需要隔离的任务，而线程更适用于利用cpu执行代码、并发执行共享数据的任务。

2.线程属于进程，线程无法像线程分配资源，但线程可以访问资源

3.进程切换由于涉及到上下文很笨重，而线程切换更轻量级

4.cpu执行代码的真正方式是用线程执行

5.线程是进程的一小部分，一个进程可以有多个线程



## 注意事项

### 模块导入时注意不要循环导入

​	此问题常常出现为路由函数没有被执行。由于**每一模块导入后只会导入一遍**，如果循环导入后，比如在模块a里导入了模块b，模块b里又导入了模块a，此外模块b里存放路由函数，如果先执行模块a，执行到导入模块b的语句后就会跳转到模块b中的文件，但是模块b中，导入语句会放在该模块的开头部分，这将会导致读取到导入模块a的语句后就跳转到模块a的代码中，继续执行a中导入b的下一行语句，此时就导致了模块b中的路由函数就没有被执行

![image-20230905193340224](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905193340224.png)

![image-20230905193438070](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905193438070.png)

​	此外，在这种情况下，**模块a中的main函数也不会被执行**，因为第二次进入模块a是由于模块b的导入语句造成的跳转，此时`__name__`就不等于`‘__main__’`了，只有直接进入模块a而非由于导入的情况才有`__name__ == '__main__'`

​	代码此时还没有走完，由于模块a中的if不成立，后面又没有代码了，所以就会调回模块b继续执行代码，此时才会执行模块b中的视图函数，走完模块b后，又会回到最初模块a导入模块b的语句`from app.web import book`中，此时才会进入`if __name__ == '__main__':`语句中，因为这次，是回到最开始文件直接进入模块a开始读取代码的一次，并非由于其他模块的导入，是导入完后回到a，而不是由b导入a的跳转。

​	执行`if __name__ == '__main__':`里run函数后，web服务器才开始启动，整个函数流程就结束了

​	路由函数中的代码没有在网页中 呈现的原因：模块a中下面语句被执行了两次，也就是flask的核心对象——app被初始化了两次，形成了两个app对象

```py
app = Flask(__name__)
```

​	也就是我们用于注册视图函数的app和启动web服务器的app不是同一个：

​	第一次直接进入模块a中时：没有执行b中的视图函数，但是最终启动了web服务器

​	第二次由b导入进入模块a时：由于不是直接进入a中，所以`__name__ == '__main__':`不成立，没有启动服务器，执行完a中代码后回到b，执行了b的视图函数

​	

**直观查看：**打印对象所在的地址——id函数



模块a中：

在app对象产生后立刻打印该对象的地址

![image-20230905195611429](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905195611429.png)

main函数里也打印一次

![image-20230905195705450](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905195705450.png)

模块b中：

![image-20230905195946318](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905195946318.png)

运行结果：app实例化了两次，有两个不同的地址

![image-20230905200719945](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230905200719945.png)





### flask框架

最顶层的是flask的实例化的核心对象——app

第二层是蓝图，蓝图并不能独立存在，它依赖于app，因此第二层就是app对象它插入了很多蓝图

第三层是每个蓝图上插入的视图函数，除了视图函数之外，还能指定它的静态文件夹和模板文件夹



![image-20230906192326917](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230906192326917.png)

利用此结构也可以解决将视图函数从app对象所在的文件上分离，比如将视图函数写在蓝图中而不是直接app上





### request

​	request在flask中的实现其实是一种代理模式的实现，也就是说，如果要**使用request就需要保证request所在的这个方法必须是由http请求来触发的**，比如说，之所以可以在视图函数中直接使用request对象，是因为视图函数的触发，是由于用户的请求来触发和引起的。

​	因此request的使用的有一个误区，





### 问题

## 1.无法进入main函数

直接运行该文件时，name文件无法执行

![image-20230907164032362](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230907164032362.png)

可能是因为我新建项目时使用的是，flask项目，而不是一般的python文件



### 2.无法识别requests模块

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230907173722245.png" alt="image-20230907173722245" style="zoom:50%;" />

<img src="C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230907172832702.png" alt="image-20230907172832702" style="zoom:50%;" />

服了，运行项目的调试器不一样

![image-20230907180516702](C:\Users\41001\AppData\Roaming\Typora\typora-user-images\image-20230907180516702.png)





### 注意

1.路由的写法

```py
@web.route('/book/search/<q>/<page>')
```

这种有<>，url中参数格式就为：

```py
@web.route('/book/search')
```

这种参数就需要?q=9787501524044 & page=...
